# 常见面试题

## 计算机网络

1. 网络模型和协议

![](https://uploadfiles.nowcoder.com/images/20190814/980266035_1565787665824_1ABB2DC3D76311944FFDBE9980FBAADD)

2. TCP和UDP的区别

3. UDP如何保证可靠

4. TCP、UDP、IP报文格式

5. 三次握手四次挥手

TCP三次握手

**TCP运输连接有三个阶段：连接建立、数据传送、连接释放**

TCP连接过程通常叫做**握手**，握手需要客户端和服务器端交换三个报文，如下图所示之所以需要三次握手是因为TCP是可靠传输，三次能够刚好可靠又不多余TCP三次握手与Socket的连接过程是相关联对应的，Socket就是对于TCP/IP的封装么**客户端有CLOSED、SYN-SEND、ESTABLISHED三种状态****客户端有CLOSED、LISTEN、SYN-RCVD、ESTABLISHED四种状态服务器会首先创建连接，并且进入监听等待阶段，等待客户端的请求当需要发送请求时，浏览器客户端主动打开连接，然后服务器被动打开连接**![img](https://uploadfiles.nowcoder.com/images/20190828/8309948_1566974042905_FC5D1E4A8542CB51426DC924E8578CD5)

连接过程客户端在需要时，向服务器发起请求连接报文，发出后状态从CLOSED转换为SYN-SEND 同步-已发送状态服务器一直处于LISTEN状态，接收到请求后，对客户端的请求进行回应，转换为SYN-RCVD，同步-已收到状态客户端收到服务器的回应后，状态转换为ESTABLISHED，并且再次向服务器发送确认服务器收到客户端的确认之后，服务器也转换为ESTABLISHED状态，完成了连接**发出消息或者收到消息后状态才会进行切换****客户端与服务器的握手是一个往复确认的过程**客户端：发出确认请求，SYN=1，seq=x，你听得到么，我想建立连接（SYN=1），我的序号是x（seq=x）服务器：对请求进行确认，也就是回应，我听到了（ACK=1，ack=x+1），你听得到么（SYN=1），我的序号是y（seq=y）客户端：对服务器的回应进行确认，我听到了（ACK=1，ack=y+1），我的序号是x+1IP数据报经过运输层需要分段发送，所以在TCP的处理过程中，有**序号**的概念比如客户端说我要从666号开始，发送100个数据，服务器说，我是从888号开始回应的上面的seq=x 和 seq=y  seq=x+1（上一个seq=x，下一个自然就是seq=x+1了）都是各自的序号**握手的过程就是SYN seq  ACK ack的来回确认**SYN ACK是头部的字段，可以理解为标志位，协议中有对他们的值有具体的规定ack就是确认号，确认号是期望收到的对方的下一个报文段的第一个数据字节的序号，也就是收到的序号+1否则随便一个，怎么对得上号为什么要三次握手？如果不是三次握手，只有两次如果客户端发出请求连接时，报文延时了，于是客户端重新发送了一次连接请求消息后来收到了确认，建立了连接，然后完成了数据传输，关闭了连接此时，服务器收到了那个迟到的请求消息，此时他应该是个废物了但是如果只有两次握手，服务器收到请求就响应建立了连接了但是如果是三次，客户端不会再次确认，服务器也就随后知道了这消息有问题，不会建立连接TCP四次挥手连接建立以后就可以进行数据通信传输了通信结束后，需要断开连接，断开连接需要四次交互，常被称为**四次挥手****最初状态均为ESTABLISHED**，客户端与服务器相互进行数据传送下图假设客户端无数据发送，请求断开连接![img](https://uploadfiles.nowcoder.com/images/20190828/8309948_1566974066111_035082E832E529B2DFF7F11FE4D076A4)

断开过程

客户端无数据发送时，请求关闭连接，我好了，我想断开连接了（FIN=1）我的序号是u（u就是之前传送过的所有数据的最后一个字节的序号+1）此时客户端转变为FIN-WAIT-1状态服务器收到客户端的消息后，告诉客户端“好的，我知道了”（ACK=1，ack=u+1），这条消息的序号是v（seq=v ，这是服务器发送消息的序号)此时服务器的状态就转换为了CLOSE-WAIT状态此时，客户端通往服务器的路就断开了，客户端不能向服务器发送数据但是服务器仍旧可以向客户端发送数据，现在是“半关闭”的状态当客户端收到来自服务器的确认之后，进入FIN-WAIT-2状态，等待服务器那边说断开连接，等待中。。。。。当服务器所有的数据也都完全发送完成了之后，服务器才开始主动告知客户端断开连接（FIN=1，seq=w）这中间服务器可能又继续发送了一些数据，可能是v+1 也可能发送了更多，所以设置为w并且再次发送确认信息（ACK=1，ack=u+1，因为客户端已经不能发送数据了，服务器期望收到的序号永远都是最后一个序号+1，也就是u+1）这时，服务器就进入了LAST-ACK状态，最后确认状态客户端收到了服务器的断开连接请求后，也需要给出确认响应（ACK=1，ack=w+1，seq=u+1），然后进入TIME-WAIT状态等待两个MSL后，进入关闭状态MSL 是Maximum Segment Lifetime英文的缩写“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。服务器最终收到来自客户端的确认信息后，关闭，进入CLOSED状态

**四次挥手也是一个互相确认的过程，你说不玩了，别人答应了，还要等别人都搞好了再告诉你可以走了，你才能走**

客户端：我不想玩了服务器：好的我知道了

服务器：你可以走了

客户端：好的我走了

就如同在网吧上网，你点击下机之后，再去网管那边结账结账清楚了之后才彻底结束，而不是你说走就走了，难道你办会员卡了么这个过程很好理解，**客户端发出请求后，并不意味着服务器都已经完成响应****所以当客户端请求断开时，并不能立即断开，还需要等待服务器那边处理妥当，再来通知你的确是可以断开了**消息发出来谁知道别人收没收到，所以还需要一个确认

6. TCP粘包

7. TCP 协议如何保证可靠传输

三次握手、四次挥手、确认机制、重传机制、滑动窗口、拥塞控制

8. TCP的流量和拥塞控制

9. ARQ协议

地址解析协议。ARP攻击的第一步就是ARP欺骗。由上述“ARP协议的工作过程”我们知道，ARP协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正确和快速的完成——ARP协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现ARP应答中的IP地址和MAC地址中的信息是可以伪造的，并不一定是自己的真实IP地址和MAC地址，由此，ARP欺骗就产生了。

10. 从浏览器中输入url之后发生了什么

1.DNS解析 

2.TCP连接 

3.发送HTTP请求 

4.服务器处理请求并返回HTTP报文 

5.浏览器解析渲染页面

11. DNS服务器基本流程

12. http get和post的区别

①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；
②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用"?"连接，而各个变量之间使用"&"连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；
③get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式；
④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；
⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是"%20"。

13. cookies和session的关系

14. 服务器怎么知道客户端已经发送数据完毕？

15. 数字证书、签名

16. HTTP1.0、1.1、2.0之间的区别

17. HTTP状态码

18. http请求报文有什么？

19. http缓存

## 操作系统

1. 进程间通信的方式

2. 线程同步的实现方式（抛开语言，操作系统里）

3. 进程调度算法

4. 死锁的必要条件和处理方法

（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。

（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。

（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源的占有者进程自行释放。

（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。

解决方法：银行家算法

5. 银行家算法，死锁

6. 虚拟内存

7. 常见的几种内存管理机制

8. 快表和多级页表

9. 页面置换算法

10. 磁盘调度算法

11. 阻塞式io和非阻塞式io的区别

12. IO多路复用，讲下select、poll、epoll

13. NIO、BIO、同步和异步的理解？

14. 协程呢？

15. 进程在自己虚拟地址空间都是什么

16. 僵尸进程、孤儿进程

## Mysql

1. 数据库事务有哪些特性

2. 脏读和幻读的区别是什么？

3. 可重复读的隔离级别下如何保证不幻读

4. 非关系型数据库和关系型数据库的区别

5. Mysql mvcc？

6. 乐观锁与悲观锁的区别

7. 数据库范式讲一下

8. 主键是什么？

9. 内连接 左连接 右连接

10. union与union all的区别

11. Explain

12. 最左前缀

13. B+树的结构？与二叉树的区别？与B树的区别？

14. Hash索引和 B+树索引优劣分析

15. 索引用B+树而不用红黑树？

16. 数据库怎么优化

17. 什么时候不该使用索引？

18. 聚集索引和非聚集索引的区别

19. Mysql知道几种存储引擎，有什么区别

20. 覆盖索引

21. 主从复制、读写分离、分库分表

22. Mysql锁划分

23. Mysql架构

24. in和exist区别

## Redis

1. Redis有哪些数据结构

2. String类型的底层实现:

3. Hash字典类型

4. Redis渐进式rehash 为什么

5. Redis中zset的内部实现跳跃表 为什么

6. Redis支持事务吗

7. Redis单线程还是多线程，为什么？

8. Redis单线程为什么还并发量那么高

9. Redis为什么快？

10. 缓存穿透以及解决

11. 缓存雪崩以及解决

12. 缓存击穿以及解决

13. redis内存满了怎么办

14. Redis持久化的方法

15. AOF重写

16. redis主从结构

17. redis哨兵

18. Redis集群

19.集群是如何判断是否有某个节点挂掉

20. 分布式锁作用

21. 一致性哈希

22. 缓存与数据库双写一致

## Kafka

Kafka队列与发布订阅

介绍下kafka都有哪些组件

kafka是怎样保证全局有序的 Kafka如何保证消息的消费顺序

kafka 有哪些保证消息不被丢失的手段  (Kafka如何保证消息的可靠性)

kafka如何防止消息重复消费？ kafka保证消息唯一

kafka副本机制 （Kafka如何保证高可用）

ISR：为何用

Kafka消息是采用Pull模式，还是Push模式？

Kafka的特点

Kafka的实现原理

Kafka存储机制

kafka写入数据时的高性能？

kafka如何保证高吞吐 kafak为什么效率比较高

kafka如何作为系统通知的过程

Kafka一致性

多个消费者能不能消费同一个分区

除了Kafka还知道哪些消息队列？

基础分布式和大数据场景

分布式锁

分布式事务

CAP、BASE

分布式ID

分布式协议

URL黑名单问题：判断值是否已经存在于集合中

20亿个32位整数中出现次数最多的数：

40亿个非负整数没出现的数：

找到100亿个URL重复的URL

40亿非负整数出现两次的数：

大数据的中位数，桶排序：

## Java集合

1. List、set、map三者的区别

   List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。

2. ArrayList和LinkedList的区别

   ArrayList和LinkedList都实现了List接口，他们有以下的不同点： 
   ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 
   相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 
   LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。

3. HashMap源码说一下（细说，从初始化到put、get、扩容、红黑树、1.8做了哪些优化）

4. Hashmap链表要转红黑树，为什么长度超过8转

5. 多线程Put可能发生的问题

6. ConcurrentHashMap的实现

7. Concurranthashmap和Hashtable的区别

8. concurrenthashmap的 size如何计算

9. LinkedHashMap，如何在o（1）的时间里面删除一个元素

10. Hashset和hashmap的区别

11. HashTable与hashMap的不同

12. TreeMap

13. List遍历时删除元素

14. 快速失败（fail—fast）、安全失败（fail—safe）

15. CopyOnWriteArrayList

16. HashMap遍历时删除元素

## Java基础

1. java有几种基本类型，分别是什么？String是基本类型吗？

2. Final、 static 、this、super关键字？

3. final，finalize， finally有什么区别

4. String、Stringbuffer和StringBuilder的区别

5. Equals方法重写时为什么要重写hashcode方法？

6. ==和equals的区别

7. 接口和抽象类的区别

8. jdk和jre的区别

9. 深拷贝、浅拷贝

10. Java中为何要有泛型？

11. 方法覆盖与重载的区别？

12. Java类初始化顺序

13. java的三大特性 面向对象的特性。（封装、继承、多态） 的含义

14. 多态的实现原理

15. Java有这些权限：public,protected,private。如果不写，那默认权限是哪个？

16. Java中类修饰符、成员变量修饰符、方法修饰符的种类与类别？

17. 什么是内存泄漏？Java中存在内存泄漏吗？

18. RuntimeException有哪些，提到了空指针异常，问怎么避免空指针异常

19. 反射了解吗，应用场景

20. Jdk动态代理原理

21. Arrays.sort()的实现？

22. Java8 有什么新特性 

## 内存模型

1. 创建对象的几种方式

2. 注解元、标准、自定义

3. 注解原理

4. Java I/O的种类

5. 怎么实现序列化与反序列化

6. 5种IO模型的区别

7. Object方法

## Java并发

1. 什么是线程？

2. java线程通信同步有几种方式

3. 多线程共享数据

4. 信号量和互斥量的区别

5. 线程是怎么实现的 线程有哪些方法？Wait()是线程的方法吗？

6. wait和sleep的区别

7. 线程实现各有什么优缺点？

8. 要用start()方法区执行run()方法而不是直接调用run()方法

9. 线程有几种状态 上下文切换

10. ThreadLocal是什么

11. 就绪状态和阻塞状态有什么区别 两者可以互相切换吗

12. 进程和线程切换开销对比

## Java中的锁

1. CAS的含义 ABA问题

2. java volatile关键字

3. 说一下volatile 指令不可重排 怎么不可重排，为什么不可重排，重排会发生什么

4. Volatile关键字和synchronized关键字

5. synchronized三种使用方式：

6. synchronized的了解

7. synchronized锁状态转换

8. synchronized实现原理？

9. synchronized和Lock的区别？

10. AQS，基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍

11. CyclicBarrier 和 CountDownLatch 的区别

12. 非公平锁和公平锁

13. JUC原子类

14. 两个线程读，一个线程写，如何实现，不用锁可以吗

15. 线程池作用、参数、有几种

16. Executor

17. workQueue：

18. 拒绝策略有几种？

19. Java中如何正常终止线程？

20. 主线程可以捕获子线程抛出的异常吗？

21. 多线程个数？

## JVM

1. java虚拟机运行的流程

2. java虚拟机的核心设计思想

3. JAVA内存如何分配？

4. 画出java运行时内存区结构图

5. 堆区如何分类

6. 堆与栈区别

7. 为什么要把字符串常量池放到堆区

8. java8方法区的变化

9. 判断对象已经无效

10. 引用计数法实现原理

11. 哪些对象可以作为GC Root

12.  GCRoot详细

13. finalize()方法回收对象的两次标记过程

14. Java四种引用及场景

15. 垃圾回收算法和流程

16. 如何减少full gc的次数？

17. 方法区是否需要gc

18. 查看GC状态的命令

19. CMS收集器的流程

20. G1收集器的流程

21. CMS收集器和G1收集器的区别

22. 内存管理(对象创建、布局、访问定位)

23. 堆内存分配策略

24. 查看java虚拟机内存占用？

25. java的类加载流程

## 类加载器

1. 类加载器的双亲委派

2. 为什么需要双亲委派

3. 线程上下文类加载器

4. 对象的创建过程

5. Class类文件怎么回收

6. Minor Gc和FULL Gc的区别

## 框架

框架的话其实就ioc、AOP、Bean生命周期、MVC最好还是搭配技术内幕看看源码，不用很广，需要深度